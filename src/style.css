.ProseMirror {
  & .flat-list {
    padding: 0;
    margin-top: 0;
    margin-bottom: 0;
    margin-left: 32px;
    margin-bottom: 0;

    position: relative;
    display: list-item;
  }

  & .flat-list[data-list-type='bullet'] {
    list-style: disc;
  }

  & .flat-list[data-list-type='ordered'] {
    list-style: none;
    counter-reset: remirror-ordered-item-number;
    counter-increment: remirror-ordered-item-number;
    & + & {
      counter-reset: none;
    }
    &::marker {
      content: counter(remirror-ordered-item-number, decimal) '. ';
    }
  }

  & .flat-list[data-list-type='task'] {
    list-style: none;

    & > .item-mark-container {
      position: absolute;
      right: 100%;
      white-space: pre;

      /* Add a suffix after the marker, just like how bullet and ordered list do */
      &::after {
        content: ' ';
      }

      /* TODO: Why do I need to set the pointer twice? */
      & > label {
        cursor: pointer;
      }
      & > label > input {
        cursor: pointer;
      }
    }
  }

  & .flat-list[data-list-type='toggle'] {
    list-style: none;

    & > .item-mark-container {
      position: absolute;
      right: 100%;
      white-space: pre;
      font-size: 1.2em;
      font-weight: 600;
    }

    /*
    https://www.w3.org/TR/css-counter-styles-3/#disclosure-open 

    For example, the disclosure-closed style might use the characters U+25B8
    BLACK RIGHT-POINTING SMALL TRIANGLE (▸) and U+25C2 BLACK LEFT-POINTING
    SMALL TRIANGLE (◂), while the disclosure-open style might use the
    character U+25BE BLACK DOWN-POINTING SMALL TRIANGLE (▾).
    */
    &:not([data-list-collapsed]) > .item-mark-container::after {
      content: '▾ ';
    }
    &[data-list-collapsed] > .item-mark-container::after {
      content: '▸ ';
    }

    /* The list node has only one child */
    &:not(:has(> .item-content-container > *:nth-child(n + 2))) {
      /* Make the marker gray */
      & > .item-mark-container {
        opacity: 40%;
      }

      /* Always show to down triangle */
      & > .item-mark-container::after {
        content: '▾ ';
      }
    }

    /* The list node has two or more children */
    &:has(> .item-content-container > *:nth-child(n + 2)) {
      /* Make the marker clickable */
      & > .item-mark-container {
        cursor: pointer;
      }

      /* If collapsed, hide the second and futher children */
      &[data-list-collapsed] > .item-content-container > *:nth-child(n + 2) {
        display: none;
      }
    }
  }
}
